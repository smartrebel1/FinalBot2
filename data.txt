import os
import logging
import requests
import difflib
import re
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
from dotenv import load_dotenv
import httpx
import uvicorn
import time

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("bot")

logger.info("ğŸš€ BOT RUNNING WITH LLAMA-3.3-70B-VERSATILE (GROQ)")

load_dotenv()

VERIFY_TOKEN = os.getenv("FACEBOOK_VERIFY_TOKEN")
PAGE_TOKEN = os.getenv("FACEBOOK_PAGE_ACCESS_TOKEN")
GROQ_API_KEY = os.getenv("GROQ_API_KEY")

MODEL = "llama-3.3-70b-versatile"

app = FastAPI()


@app.get("/")
def home():
    return {"status": "alive", "model": MODEL}


@app.get("/webhook")
def verify(request: Request):
    mode = request.query_params.get("hub.mode")
    token = request.query_params.get("hub.verify_token")
    challenge = request.query_params.get("hub.challenge")

    if mode == "subscribe" and token == VERIFY_TOKEN:
        return int(challenge)

    raise HTTPException(status_code=403)


# =============================
# ğŸ”¥ Ø°ÙƒØ§Ø¡ Ø§Ù„Ø±Ø¯ â€” Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø©
# =============================
async def generate_reply(user_msg: str):

    # Ø£ÙˆØ§Ù…Ø± Ø§Ù„ØªØ­ÙƒÙ…
    normalized = user_msg.strip().lower()
    if normalized in ("stop", "Ø³ØªÙˆØ¨", "Ø§Ø³ÙƒØª", "Ù‚Ù"):
        return "ğŸ¤ Ø­Ø§Ø¶Ø±ØŒ Ù‡Ø³ÙƒØª Ø¯Ù„ÙˆÙ‚ØªÙŠâ€¦ Ù‚ÙˆÙ„ *Ø±Ø¬ÙˆØ¹* Ù„Ù…Ø§ ØªØ­Ø¨ Ø£ÙƒÙ…Ù„ â¤ï¸"
    if normalized in ("Ø±Ø¬ÙˆØ¹", "ÙƒÙ…Ù„", "continue", "start"):
        return "âœ… Ø±Ø¬Ø¹Øª Ù…Ø¹Ø§Ùƒâ€¦ ØªØ­Øª Ø£Ù…Ø±Ùƒ! ğŸ˜Š"

    # ØªØ­Ù…ÙŠÙ„ data.txt
    data_text = ""
    if os.path.exists("data.txt"):
        with open("data.txt", "r", encoding="utf-8") as f:
            data_text = f.read()

    # -------------------------------
    # 1) Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù…Ù†ÙŠÙˆ MENU_LINK
    # -------------------------------
    menu_links = []
    for line in data_text.splitlines():
        if line.upper().startswith("MENU_LINK:"):
            menu_links.append(line.split(":", 1)[1].strip())

    # -------------------------------
    # 2) Ø§Ù„Ø¨Ø­Ø« Ø¥Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø·Ù„Ø¨ Ø§Ù„Ù…Ù†ÙŠÙˆ
    # -------------------------------
    if re.search(r"(Ù…Ù†ÙŠÙˆ|Ù‚Ø§Ø¦Ù…Ø©|menu)", user_msg):
        if menu_links:
            links_text = "\n".join(f"ğŸ”— {l}" for l in menu_links)
            return f"ğŸ“‹ ØªÙØ¶Ù„ Ø§Ù„Ù…Ù†ÙŠÙˆ ÙƒØ§Ù…Ù„:\n{links_text}\n\nğŸ“© Ø³ÙŠØªÙ… Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ ÙÙŠ Ø£Ù‚Ø±Ø¨ ÙˆÙ‚Øª."

    # -------------------------------
    # 3) ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ø¯Ø§Ø®Ù„ data.txt
    # -------------------------------
    products = {}  # name_lower â†’ (display_name, price, unit)

    for line in data_text.splitlines():
        if ":" not in line:
            continue

        name_part, rest = line.split(":", 1)
        name = name_part.strip()

        rest = rest.replace(",", "")

        match = re.search(r"([0-9\.]+)\s*â€”\s*([A-Za-z\u0600-\u06FF0-9% ]+)", rest.strip())
        if match:
            price = match.group(1)
            unit = match.group(2).strip()
        else:
            continue

        products[name.lower()] = (name, price, unit)

    # Ù„Ùˆ Ù…ÙÙŠØ´ Ø£ÙŠ Ù…Ù†ØªØ¬Ø§Øª
    if not products:
        return "âš ï¸ Ù„Ù„Ø£Ø³Ù Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø± ØºÙŠØ± Ù…ØªØ§Ø­Ø© Ø§Ù„Ø¢Ù†. Ø³ÙŠØªÙ… Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ."

    # -------------------------------
    # 4) Fuzzy Search (Ø°ÙƒØ§Ø¡ Ø¥ØµÙ„Ø§Ø­ Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø¥Ù…Ù„Ø§Ø¡)
    # -------------------------------
    query = user_msg.lower().strip()

    best_matches = difflib.get_close_matches(query, list(products.keys()), n=3, cutoff=0.65)

    # Ù„Ùˆ Ù…ÙÙŠØ´ ØªØ·Ø§Ø¨Ù‚ Ù…Ø¨Ø§Ø´Ø±ØŒ Ø¬Ø±Ø¨ ÙƒÙ„Ù…Ø§Øª Ù…Ù†ÙØµÙ„Ø©
    if not best_matches:
        words = re.findall(r"[\w\u0600-\u06FF]+", query)
        for w in reversed(words):
            sub = difflib.get_close_matches(w, list(products.keys()), n=2, cutoff=0.7)
            if sub:
                best_matches = sub
                break

    # -------------------------------
    # 5) Ù„Ùˆ ÙˆØ¬Ø¯ Ù…Ù†ØªØ¬ ÙØ¹Ù„Ø§Ù‹
    # -------------------------------
    if best_matches:
        best = best_matches[0]
        display_name, price, unit = products[best]

        return (
            f"ğŸ§¾ **{display_name}**\n"
            f"ğŸ’° Ø§Ù„Ø³Ø¹Ø±: {price} Ø¬Ù†ÙŠÙ‡\n"
            f"ğŸ“¦ Ø§Ù„ÙˆØ­Ø¯Ø©: {unit}\n\n"
            f"Ù‡Ù„ ØªØ­Ø¨ ØªØ·Ù„Ø¨Ù‡ØŸ ğŸ˜Š"
        )

    # -------------------------------
    # 6) Ù…ÙÙŠØ´ Ù…Ù†ØªØ¬ â†’ Ø±Ø¬Ù‘Ø¹ Ø§Ù„Ù…Ù†ÙŠÙˆ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„
    # -------------------------------
    if menu_links:
        links_text = "\n".join(f"ğŸ”— {l}" for l in menu_links)
        return (
            f"â— Ø§Ù„Ù…Ù†ØªØ¬ Ø§Ù„Ù„ÙŠ Ø¨ØªØ¯ÙˆØ± Ø¹Ù„ÙŠÙ‡ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.\n"
            f"ğŸ“‹ ØªÙ‚Ø¯Ø± ØªØ´ÙˆÙ Ø§Ù„Ù…Ù†ÙŠÙˆ Ø§Ù„ÙƒØ§Ù…Ù„ Ù‡Ù†Ø§:\n{links_text}\n\n"
            f"ğŸ“© Ø³ÙŠØªÙ… Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ ÙÙŠ Ø£Ù‚Ø±Ø¨ ÙˆÙ‚Øª."
        )
    else:
        return "â— Ø§Ù„Ù…Ù†ØªØ¬ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯. ğŸ“© Ø³ÙŠØªÙ… Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ùƒ Ù‚Ø±ÙŠØ¨Ù‹Ø§."


# =====================================================
# ğŸ”¥ Ù†Ø¸Ø§Ù… Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ù…Ù† ÙÙŠØ³Ø¨ÙˆÙƒ
# =====================================================
@app.post("/webhook")
async def webhook(request: Request):
    body = await request.json()
    logger.info(f"ğŸ“© Incoming Event: {body}")

    if body.get("object") == "page":
        for entry in body["entry"]:
            for msg in entry.get("messaging", []):
                if "message" in msg and "text" in msg["message"]:
                    sender = msg["sender"]["id"]
                    text = msg["message"]["text"]

                    logger.info(f"ğŸ‘¤ User {sender}: {text}")

                    reply = await generate_reply(text)
                    send_message(sender, reply)

        return JSONResponse({"status": "ok"}, status_code=200)

    return JSONResponse({"status": "ignored"}, status_code=200)


# =====================================================
# Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ù„Ù…Ø§Ø³Ù†Ø¬Ø±
# =====================================================
def send_message(user_id, text):
    url = f"https://graph.facebook.com/v19.0/me/messages?access_token={PAGE_TOKEN}"

    payload = {
        "recipient": {"id": user_id},
        "message": {"text": text}
    }

    r = requests.post(url, json=payload)
    logger.info(f"ğŸ“¤ Sent to {user_id} | Status {r.status_code}")


# =====================================================
# Server runner
# =====================================================
if __name__ == "__main__":
    port = int(os.getenv("PORT", 8080))
    uvicorn.run(app, host="0.0.0.0", port=port)